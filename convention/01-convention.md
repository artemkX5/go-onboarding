Конвенция golang команды

I Используем разделение структур на структуры для хранения данных и для бизнес-логики (НЕ используем паттерн active record)

https://en.wikipedia.org/wiki/Active_record_pattern
```go
// Структура для данных
type SomeData struct {
    Name string json:"name"
    SecondName string json:"second_name"
}

// Структура для логики
type SomeLogic interface {
    Do() error
}

type someLoginc struct {
    someProcessor someProcessor
    someParser    someParser
}
```

II Структура проекта должна соответствовать пакетно-ориентированной архитектуре (все пакеты лежат в internal), Каждый пакет выполняет только одну задачу

https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html

III Структура стандартного go файла со структурой, выполняющей некую бизнес-логику 

IV Используем прием работы "по контракту"

V Используем архитектурный прием разделения бизнес-логики сервиса и транспортной составляющей

VI В проекте должна быть оформлена сопровождающая документация в файле README.md

Допускается README.md как в корне проекта, так и в каждом разделе директории cmd

VII Используем архитектурный прием "Изоляция пакетов"
```go
// Применяем приватные интерфейсы
type some interface {
    Do() error
}

type another struct {
    someWorker some
}
```
VIII Используем архитектурный прием "Инверсия зависимостей"

Все зависимости логическая сущность получает при инициализации (фабрика) или в рантайме (метод)

# Разделение бизнес-логики сервиса и транспортной составляющей

## UML диаграммы

Что такое UML?

https://ru.wikipedia.org/wiki/UML

### Диаграмма компонентов
Описываем компоненты, которые участвуют в алгоритме

https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2

### Диаграмма последовательности
Описываем алгоритм на компонентах

https://ru.wikipedia.org/wiki/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0_%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8

### PlantUML
https://plantuml.com/ru/

В GOLAND ставим плагин plantuml - все схемы описываем в папке doc

# Поставка кодом
1. Бизнес логика описывается в файле service.go. Интерфейс - контракт поведения нашего сервиса
2. Общение между сервисами может быть построено на множестве разных протоколов, но пока мы используем протокол http и библиотеку fasthttp:

https://habr.com/ru/post/443378/
https://github.com/valyala/fasthttp
```go
// Service ... 
type Service interface { 
	Create(ctx context.Context, token *string) (count int, err error) 
	Update(ctx context.Context, details *string) (updated bool, err error) 
}
```

# Client
Eсли бы не было клиента, то нам приходилось бы прямо из бизнес логики порождать зависимости над библиотеками типа net/http. Под клиентом мы скрываем то, как ходим в другой сервис (fasthttp/grpc/http и прочее).

Если у нас пришло требование изменить транспорт с http на grpc, то мы практически не будем менять клиент. По сути понижаем связанность компонент для более простой миграции.

Когда мы используем клиент, то мы говорим другому сервису - если хочешь использовать наш сервис, то тебе достаточно использовать наш интерфейс и по нему сгенерировать клиента и тебе не нужно знать ничего про транспорт, который будет использоваться под капотом.

# JSON
Для того чтобы сделать более дешевым процесс маршалинга-анмаршалинга пользуемся библиотекой easyjson: https://github.com/mailru/easyjson